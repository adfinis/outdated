from __future__ import annotations

from datetime import date
from re import compile
from typing import TYPE_CHECKING

import pytest
from requests import exceptions

from outdated.outdated.parser import LockfileParser
from outdated.outdated.tracking import Tracker

if TYPE_CHECKING:
    from pytest_django.fixtures import SettingsWrapper
    from pytest_mock import MockerFixture
    from requests_mock import Mocker

POETRY_LOCK_CONTENT = """
# This file is automatically @generated by Poetry 1.6.1 and should not be changed by hand.
[[package]]
name = "django"
version = "4.2.6"

[[package]]
name = "djangorestframework"
version = "3.14.0"
"""

POETRY_LOCK_EXPECTED = [
    "django 4.2.6",
    "djangorestframework 3.14.0",
]

# the dependencies are kept to test the regex
YARN_LOCK_CONTENT = """
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


ember-source@^5.4.0:
  version "5.4.0"
  dependencies:
    "@babel/helper-module-imports" "^7.16.7"
    "@ember/edition-utils" "^1.2.0"
    "@glimmer/component" "^1.1.2"
    "@simple-dom/interface" "^1.4.0"
    babel-plugin-debug-macros "^0.3.4"
    ember-router-generator "^2.0.0"
    router_js "^8.0.3"
    semver "^7.5.2"
    silent-error "^1.1.1"

ember-data@^5.3.0:
  version "5.3.0"
  dependencies:
    "@ember-data/adapter" "5.3.0"
    "@embroider/macros" "^1.13.1"
    ember-inflector "^4.0.2"
    webpack "^5.88.2"

"""


YARN_LOCK_EXPECTED = [
    "ember-source 5.4.0",
    "ember-data 5.3.0",
]

# the contents of the package do not matter as we get all required information from the key
PNPM_LOCK_CONTENT = """
lockfileVersion: '6.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false


devDependencies:
  ember-cli:
    specifier: ^4.12.0
    version: 4.12.2
  ember-source:
    specifier: ^4.12.0
    version: 4.12.3(@babel/core@7.23.2)(@glimmer/component@1.1.2)(webpack@5.89.0)

packages:

  /ember-cli@4.12.2:
    dev: true

  /ember-source@4.12.3(@babel/core@7.23.2)(@glimmer/component@1.1.2)(webpack@5.89.0):
    dev: true
"""

PNPM_LOCK_EXPECTED = [
    "ember-source 4.12.3",
    "ember-cli 4.12.2",
]


@pytest.mark.parametrize(
    "lockfile,content,expected",
    [
        ("yarn.lock", YARN_LOCK_CONTENT, YARN_LOCK_EXPECTED),
        ("pnpm-lock.yaml", PNPM_LOCK_CONTENT, PNPM_LOCK_EXPECTED),
        ("poetry.lock", POETRY_LOCK_CONTENT, POETRY_LOCK_EXPECTED),
    ],
)
def test_parser(db, tmp_repo_root, project, lockfile, content, expected):
    project_path = tmp_repo_root / project.clone_path
    project_path.mkdir(parents=True, exist_ok=False)

    lockfile_path = project_path / lockfile

    lockfile_path.write_text(content)

    tracker = Tracker(project)
    lockfiles = tracker.lockfiles

    assert len(lockfiles) == 1
    assert lockfiles[0].name == lockfile

    results = LockfileParser(lockfiles).parse()

    assert len(results) == len(expected)

    for result in results:
        assert str(result) in expected


@pytest.mark.django_db()
@pytest.mark.parametrize(
    "dependency_names,associations,call_count",
    [
        (
            ["ember-data", "ember-cli", "ember-source", "ember-modifier"],
            {
                "ember-(data|source|cli)": "emberjs",
            },
            3,
        ),
        (
            ["django", "django-restframework"],
            {
                "django": "django",
            },
            1,
        ),
        (
            ["djangorestframework", "django-environ"],
            {
                "django": "django",
            },
            0,
        ),
    ],
)
def test_fetch_end_of_life(
    settings: SettingsWrapper,
    mocker: MockerFixture,
    dependency_names: list[str],
    associations: dict,
    call_count: int,
    requests_mock: Mocker,
) -> None:
    settings.ENDOFLIFE_DATE_ASSOCIATIONS = associations
    mocker.patch.object(
        LockfileParser, "_get_release_date", return_value=date(2024, 1, 1)
    )
    get_end_of_life_date_spy = mocker.spy(LockfileParser, "_get_end_of_life_date")

    requests_mock.get(
        compile("https://endoflife.date/api/[-a-z]+/4.4"),
        json={
            "lts": True,
            "releaseDate": "2023-04-03",
            "support": "2023-12-04",
            "eol": "2026-04-01",
            "latest": "4.2.9",
            "latestReleaseDate": "2024-01-02",
        },
    )
    for dependency_name in dependency_names:
        LockfileParser([])._get_version((dependency_name, "4.4.1"), provider="PIP")  # noqa: SLF001
    assert get_end_of_life_date_spy.call_count == call_count


@pytest.mark.django_db()
@pytest.mark.parametrize(
    "exception", [exceptions.ConnectTimeout, exceptions.ReadTimeout]
)
def test_fetch_end_of_life_ignore_timeout(mocker, requests_mock, exception):
    mocker.patch.object(
        LockfileParser, "_get_release_date", return_value=date(2024, 1, 1)
    )
    requests_mock.get(compile("https://endoflife.date/api/[-a-z]+/4.4"), exc=exception)
    LockfileParser([])._get_version(("django", "4.4.1"), provider="PIP")  # noqa: SLF001


@pytest.mark.django_db()
def test_fetch_end_of_life_invalid_json(mocker, requests_mock):
    mocker.patch.object(
        LockfileParser, "_get_release_date", return_value=date(2024, 1, 1)
    )
    requests_mock.get(
        compile("https://endoflife.date/api/[-a-z]+/4.4"),
        text="503 Service Temporarily Unavailable",
        status_code=503,
    )
    LockfileParser([])._get_version(("django", "4.4.1"), provider="PIP")  # noqa: SLF001
